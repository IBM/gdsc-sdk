# coding: utf-8

"""
    IBM Guardium Data Security Center

    Use Guardium Data Security Center SDK (application programming interfaces) to interact with other applications, such as Guardium Data Protection, universal connectors, and Guardium Data Security Center reports.

    The version of the OpenAPI document: 3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from ibm_gdsc_sdk_saas.models.notificationsv3_notification_severity import Notificationsv3NotificationSeverity
from ibm_gdsc_sdk_saas.models.notificationsv3_notification_state import Notificationsv3NotificationState
from ibm_gdsc_sdk_saas.models.notificationsv3_template_property import Notificationsv3TemplateProperty
from typing import Optional, Set
from typing_extensions import Self

class Notificationsv3UpdateNotificationRecordRequest(BaseModel):
    """
    A request to update a specific notification with the specified fields. The ID field is required, all other fields are optional. Specified fields will be used to included in the persisted NotificationRecord.  If no fields are specified then the  notification record update is not performed.  If the ID is not specified an error is returned.
    """ # noqa: E501
    notification_id: Optional[List[StrictStr]] = Field(default=None, description="Unique IDs for notifications; required for update.")
    severity: Optional[Notificationsv3NotificationSeverity] = Notificationsv3NotificationSeverity.UNDEFINED
    state: Optional[Notificationsv3NotificationState] = Notificationsv3NotificationState.UNREAD
    template_data: Optional[List[Notificationsv3TemplateProperty]] = Field(default=None, description="Not required for update.")
    __properties: ClassVar[List[str]] = ["notification_id", "severity", "state", "template_data"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Notificationsv3UpdateNotificationRecordRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in template_data (list)
        _items = []
        if self.template_data:
            for _item_template_data in self.template_data:
                if _item_template_data:
                    _items.append(_item_template_data.to_dict())
            _dict['template_data'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Notificationsv3UpdateNotificationRecordRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "notification_id": obj.get("notification_id"),
            "severity": obj.get("severity") if obj.get("severity") is not None else Notificationsv3NotificationSeverity.UNDEFINED,
            "state": obj.get("state") if obj.get("state") is not None else Notificationsv3NotificationState.UNREAD,
            "template_data": [Notificationsv3TemplateProperty.from_dict(_item) for _item in obj["template_data"]] if obj.get("template_data") is not None else None
        })
        return _obj


